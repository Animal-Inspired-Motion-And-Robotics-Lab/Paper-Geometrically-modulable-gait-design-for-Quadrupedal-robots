% This script plots the net displacement generated by two paths in a 2-beat gait as a function of the path's input scaling.
function plotnetdispofnoslip2bgaits(datai, dataj, dataij)
    
    % unpack plotting data
    path_i = dataij.path_i; path_j = dataij.path_j;
    lW_V_i = datai{1}.lW_V; iQ_i = datai{1}.iQ;
    lW_c_i = datai{1}.lW_contour; fA_i = datai{1}.fA; 
    cfLvl_i = datai{1}.cfLvl; cLvl_i = datai{1}.cLvl;
    gc_col_i = datai{1}.gc_col; gc_col_j = dataj{1}.gc_col; col_backg_i = datai{1}.col_backg;
    col_i = datai{1}.col; CUB_i = datai{1}.CUB; CUB_alt = dataij.CUB_alt;
    titleFS_i = datai{1}.titleFS; tickFS_i = datai{1}.tickFS; cbarFS_i = datai{1}.cbarFS;
    labelFS_i = datai{1}.labelFS; sgtitleFS_i = datai{1}.sgtitleFS;
    vidF_i = datai{6};
    path_i = datai{5};
    pltkin_i = datai{4};
    a_i = datai{3}.aa; l_i = datai{3}.ll;
    lW_i = datai{1}.lW;
    lW_r_i = datai{1}.lW_r;
    lW_kq_i = datai{1}.lW_kq;
    lW_b_i = datai{1}.lW_b;
    lW_qf_i = datai{1}.lW_qf;
    circS_i = datai{1}.circS;
    frame_scale_i = 0.25;
    c_i = path_i.path_active_color;
    zx_i = path_i.net_displacement(1,:);
    zy_i = path_i.net_displacement(2,:);
    ztheta_i = path_i.net_displacement(3,:);
    dnum_i = datai{3}.dnum; 
    cs_idx_i = datai{3}.cs_idx;
    ank = datai{3}.ank;
    cs_i = datai{3}.cs;
    cs_j = dataj{3}.cs;
    
    % unpack data for plotting
    u_i_stpt = dataij.u(1);     % set-points for the gait construction
    u_j_stpt = dataij.u(2);
    u_i = dataij.u_i;           % arrays
    u_j = dataij.u_j;
    u_i_S = dataij.u_i_S;       % 2D arrays/sweeps
    u_j_S = dataij.u_j_S;
    % idxLoc = (fliplr(u_i_S) == u_i_stpt) & (flipud(u_j_S) == u_j_stpt); % index location of the current setpoint
    idxLoc = (u_i_S == u_i_stpt) & (u_j_S == u_j_stpt);
    kappa_S = dataij.kappa_S;
    gaits = dataij.gaits;       % ui, uj swept gaits
    
    % get the axis limits
    ui_lim = [min(u_i) max(u_i)];
    uj_lim = [min(u_j) max(u_j)];

    % get the net displacement information as a function of the input space
    zxu = nan(numel(u_i), numel(u_j)); zyu = zxu; zthetau = zxu;
    for idxi = 1:numel(u_i)
        for idxj = 1:numel(u_j)
            zxu(idxi, idxj)     = gaits{idxi, idxj}.trajectory{15};
            zyu(idxi, idxj)     = gaits{idxi, idxj}.trajectory{16};
            zthetau(idxi, idxj) = gaits{idxi, idxj}.trajectory{17};
        end
    end
    z.zxu = zxu; z.zyu = zyu; z.zthetau = zthetau;

    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % 
    % % if this is a scaling subspace, then compute and plot the ellipsoid ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    % if strcmp(datai{1}.mode, "scale") && strcmp(dataj{1}.mode, "scale")
    % 
    %     % set the anisotropy ellipsoid flag
    %     flagE = true;
    % 
    %     % let's define 3 colors for the 3 cases we have right now
    %     colE = [77,175,74;
    %             255,127,0;
    %             247,129,191;
    %             37,37,37;
    %             82,82,82;
    %             130,130,130]/255;
    %     p2Cidx = 5;
    %     ccCidx = 6;
    % 
    %     % number of norm cases to explore (fixed as of now)
    %     numIter = 3;
    % 
    %     % plot related params
    %     dispNames = {'Inf', 'p2', 'p1'};
    %     linSty = {'-', '--', ':'};
    % 
    %     % initialize containers and discretization params
    %     dnum = 100; % keep this even and a multiple of 4 for now
    %     uiQ = cell(1, 3); ujQ = uiQ; zxQ = ujQ; zyQ = ujQ;
    % 
    %     % scale p2 norm req
    %     p2V = linspace(1, 0.2, 3);
    %     p2V/sqrt(2)
    % 
    %     % compute the ellipsoid for each case
    %     for iter = 1:numIter
    % 
    %         % % identify the inputs along the required ellipsoid
    %         % switch iter
    %         %     case 1 % scaling inputs' infinity norm is 1
    %         %         tempi = [ ones(1, dnum/4),         linspace(1, -1, dnum/4), -1*ones(1, dnum/4),      linspace(-1, 1, dnum/4) ]; tempi(end+1) = tempi(1);
    %         %         tempj = [ linspace(-1, 1, dnum/4), ones(1, dnum/4),         linspace(1, -1, dnum/4), -1*ones(1, dnum/4)      ]; tempi(end+1) = tempi(1);
    %         %     case 2 % scaling inputs' 2-norm is 1
    %         %         th = linspace(0, 2*pi, dnum);
    %         %         uiQ{iter} = cos(th); ujQ{iter} = sin(th);  % ui.^2 + uj.^2 = 1
    %         %     case 3 % scaling inputs' 1-norm is 1
    %         %         th = linspace(0, 2*pi, dnum);
    %         %         uiQ{iter} = cos(th); ujQ{iter} = 1 - uiQ{iter}; % ui + uj = 1
    %         % end
    % 
    %         % get the 2-norm conserved scaling inputs
    %         th = linspace(0, 2*pi, dnum);
    %         uiQ{iter} = p2V(iter)*cos(th); ujQ{iter} = p2V(iter)*sin(th);  % ui.^2 + uj.^2 = p2V(iter) % conservation law
    % 
    %         % compute the translational displacements
    %         zxQ{iter}    = interp2(u_i_S, u_j_S, z.zxu, uiQ{iter}, ujQ{iter}, "spline", nan);
    %         zyQ{iter}    = interp2(u_i_S, u_j_S, z.zyu, uiQ{iter}, ujQ{iter}, "spline", nan);
    % 
    %     end
    % 
    % end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % setting latex as the default interpreter
    set(groot,'defaultAxesTickLabelInterpreter','latex'); 
    set(groot,'defaulttextinterpreter','latex');
    set(groot,'defaultLegendInterpreter','latex');

    % parent layout
    P = [];
    P.grid = [3 1];

    % get the figure dimensions
    m = 2200*(P.grid(2))/5; % scaled figure x-resolution
    n = 1900; % fixed figure y-resolution

    % limits for the axes
    [C1_lim,C2_lim] = se2limits(zxu,zyu,zthetau);

    % limit thresholds for se(2) trajectories
    lowxy = 0.05; % 5% of the leg length
    lowtheta = deg2rad(3); % 3 degrees of orientation change
    if C1_lim(2) < lowxy && C1_lim(1) > -lowxy
        C1_lim = 0.1*[-1, 1];
    end
    if C2_lim(2) < lowtheta && C2_lim(1) > -lowtheta
        C2_lim = lowtheta*[-1, 1];
    end

    % child 1-- ith dz_translation
    C1 = []; C1.limits = C1_lim; % previously defined color limits
    C1.start = [1, 1];
    C1.grid = [2, 1]; C1.num = prod(C1.grid); C1.span_grid = C1.grid; % the tiles in the child layout matches the parent
    C1.tile_start = (C1.start(1)-1)*P.grid(2) + C1.start(2);
    C1.sweeptxt = {'zxu', 'zyu'};
    C1.titletxt = {'$$z^{x}$$', '$$z^{y}$$'};

    % child 2-- ith dz_theta
    C2 = []; C2.limits = C2_lim;
    C2.start = [3, 1];
    C2.grid = [1, 1]; C2.num = prod(C2.grid); C2.span_grid = C2.grid;
    C2.tile_start = (C2.start(1)-1)*P.grid(2) + C2.start(2);
    C2.sweeptxt = {'zthetau'};
    C2.titletxt = {'$$z^{\theta}$$'};

    % Create the figure
    figure('units','pixels','position',[100 -200 m n],'Color','w');
    set(gcf,'Visible','on'); % pop-out figure
    P = tiledlayout(P.grid(1),P.grid(2),'TileSpacing','tight','Padding','tight');

    % Initialize the child layouts
    C1.Layout_Obj = tiledlayout(P,C1.grid(1),C1.grid(2),'TileSpacing','tight','Padding','tight'); 
    C1.Layout_Obj.Layout.Tile = C1.tile_start; C1.Layout_Obj.Layout.TileSpan = C1.span_grid;
    C2.Layout_Obj = tiledlayout(P,C2.grid(1),C2.grid(2),'TileSpacing','tight','Padding','tight'); 
    C2.Layout_Obj.Layout.Tile = C2.tile_start; C2.Layout_Obj.Layout.TileSpan = C2.span_grid;

    % Child 1
    ax = cell(1, C1.num);
    for i = 1:C1.num
        ax{i} = nexttile(C1.Layout_Obj,i); % z__x & z__y
        contourf(ax{i},u_j_S,u_i_S,z.(C1.sweeptxt{i}),cfLvl_i,'LineWidth',lW_c_i,'LineStyle','none');  % ,'FaceAlpha',fA_i
        axis equal tight; hold on; view(2);
        scatter(ax{i}, u_i_stpt, u_j_stpt, circS_i, 'k', 'filled');
        colormap(ax{i},CUB_alt); clim(ax{i},C1_lim);
        % for iter = 1:numIter
        %     plot(uiQ{iter}, ujQ{iter}, linSty{iter}, 'LineWidth', 2.0, 'Color', colE(p2Cidx, :));
        % end
        % quiver(fliplr(p2V(2:end)/sqrt(2)), fliplr(p2V(2:end)/sqrt(2)), -diff(p2V/sqrt(2)), -diff(p2V/sqrt(2)), ...
        %     "off", 'LineWidth', 2.0, 'Color', colE(ccCidx, :), 'MaxHeadSize', 0.5);
        set(get(ax{i},'YLabel'),'rotation',0,'VerticalAlignment','middle');
        title(ax{i},C1.titletxt{i},'Color','k',FontSize=titleFS_i);
        if i == 1
            xlabel(ax{i},['$$u^{' num2str(cs_i(1)) num2str(cs_i(2)) '}$$'],'Color',gc_col_i,FontSize=labelFS_i); 
            ylabel(ax{i},['$$u^{' num2str(cs_j(1)) num2str(cs_j(2)) '}$$'],'Color',gc_col_j,FontSize=labelFS_i);
        end
        xticks(ax{i}, -1:1:1); yticks(ax{i}, -1:1:1); set(ax{i},'XColor',gc_col_i); set(ax{i},'YColor',gc_col_j);
        ax{i}.XAxis.FontSize = tickFS_i; ax{i}.YAxis.FontSize = tickFS_i;
        set(ax{i},'Color',col_backg_i);
        xlim(ui_lim); ylim(uj_lim);
    end
    C1.axes = ax;
    C1.colorB = colorbar(C1.axes{i},'TickLabelInterpreter','latex','FontSize',cbarFS_i); C1.colorB.Layout.Tile = 'South'; % plot the translation colorbar

    % Child 2
    ax = cell(1, C2.num);
    for i = 1:C2.num
        ax{i} = nexttile(C2.Layout_Obj,i); % just z__\theta
        contourf(ax{i},u_j_S,u_i_S,z.(C2.sweeptxt{i}),cfLvl_i,'LineWidth',lW_c_i,'LineStyle','none'); % ,'FaceAlpha',fA_i
        axis equal tight; hold on; view(2);
        scatter(ax{i}, u_i_stpt, u_j_stpt, circS_i, 'k', 'filled');
        colormap(ax{i},CUB_alt); clim(ax{i},C2_lim);
        % for iter = 1:numIter
        %     plot(uiQ{iter}, ujQ{iter}, linSty{iter}, 'LineWidth', 2.0, 'Color', colE(p2Cidx, :));
        % end
        % quiver(fliplr(p2V(2:end)/sqrt(2)), fliplr(p2V(2:end)/sqrt(2)), -diff(p2V/sqrt(2)), -diff(p2V/sqrt(2)), ...
        %     "off", 'LineWidth', 2.0, 'Color', colE(ccCidx, :), 'MaxHeadSize', 0.5);
        set(get(ax{i},'YLabel'),'rotation',0,'VerticalAlignment','middle');
        title(ax{i},C2.titletxt{i},'Color','k',FontSize=titleFS_i);
        ax{i}.XAxis.FontSize = tickFS_i; ax{i}.YAxis.FontSize = tickFS_i;
        xticks(ax{i}, -1:1:1); yticks(ax{i}, -1:1:1); set(ax{i},'XColor',gc_col_i); set(ax{i},'YColor',gc_col_j);
        set(ax{i},'Color',col_backg_i);
        xlim(ui_lim); ylim(uj_lim);
    end
    C2.axes = ax;
    C2.colorB = colorbar(C2.axes{i},'TickLabelInterpreter','latex','FontSize',cbarFS_i); C2.colorB.Layout.Tile = 'South'; % plot the rotation colorbar
    % 
    % % Display the NET SE(2) PATH CURVATURE of the current gait in console and compute everything needed to plot the heatmap
    % disp(kappa_S(idxLoc));
    % kmin = min(kappa_S, [], 'all'); kmax = max(kappa_S, [], 'all'); krange = kmax - kmin; 
    % prct = 5; % a 5% outer threshold for color limits
    % kminus = kmin-prct/100*krange; kplus = kmax+prct/100*krange;
    % if abs(kminus) < 1e-4 % our zero threshold
    %     kminus = -1e-4;
    % end
    % if abs(kplus) < 1e-4 % our zero threshold
    %     kplus = 1e-4;
    % end
    % klim = [kminus, kplus];
    % 
    % % Plot the NET SE(2) PATH CURVATURE as a separate heatmap
    % f = figure('units','pixels','position',[100 -200 m n/3],'Color','w');
    % set(f,'Visible','on'); ax = gca; % f.CurrentAxes
    % contourf(ax,u_j_S,u_i_S,kappa_S,cfLvl_i,'LineWidth',lW_c_i,'LineStyle','none'); % ,'FaceAlpha',fA_i
    % axis equal tight; hold on; view(2);
    % scatter(ax, u_i_stpt, u_j_stpt, circS_i, 'k', 'filled');
    % colormap(ax,CUB_alt); clim(ax, klim);
    % set(get(ax,'YLabel'),'rotation',0,'VerticalAlignment','middle');
    % title(ax,'$$\bar{k}$$','Color','k',FontSize=titleFS_i);
    % ax.XAxis.FontSize = tickFS_i; ax.YAxis.FontSize = tickFS_i;
    % xticks(ax, -1:1:1); yticks(ax, -1:1:1); set(ax,'XColor',gc_col_i); set(ax,'YColor',gc_col_j);
    % set(ax,'Color',col_backg_i);
    % xlim(ax, ui_lim); ylim(ax, uj_lim);
    % colorbar(ax,'TickLabelInterpreter','latex','FontSize',cbarFS_i,'Location','southoutside'); % plot the rotation colorbar

    % % plot the translational anisotropy ellipsoid (just p2 for now)
    % if flagE
    % 
    %     f = figure('units','pixels','position',[100 -200 m n/3],'Color','w');
    %     set(f,'Visible','on'); ax = gca; % f.CurrentAxes
    %     for iter = 1:numIter
    %         plot(zxQ{iter}, zyQ{iter}, linSty{iter}, 'LineWidth', 2.0, 'Color', colE(p2Cidx, :), 'DisplayName', dispNames{iter}); % just p2
    %         if iter == 1
    %             hold on; 
    %             % grid on;
    %         end
    %     end
    %     axis equal square padded; 
    %     set(ax, 'XTick', []); set(ax, 'YTick', []); set(ax, 'Visible', 'off'); box(ax, "off");
    %     % legend('location', 'bestoutside');
    % 
    % end

end