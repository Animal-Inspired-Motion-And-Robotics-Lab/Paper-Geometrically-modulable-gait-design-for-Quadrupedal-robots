function [pltTraj, traj] = stitchQuadSE2gaits(in)
%STITCHQUADSE2GAITS given a cell array of gaits, flow inputs, and repetitions for each gait this function stitches everything together into a single trajectory
%   The gait structure to obtained by running "qlevel2noslip_mp.m". Check "se2_GenericQuad_trot.mlx" notebook for more details on setting up the requirements
%   for this function.
%   in = {subgaits, gaits, input, rep}'; % required input structure
%   numel(subgaits) == numel(gaits) == numel(input) == numel(rep) % required number of elements
%   numel(input{i}) == numel(rep{i}) % for each input time within a gait struct, the number of repetitions and inputs must be equal.
    
    % ensure that the input is compatible
    if ~iscell(in)
        error('ERROR! The gaits to be stitched together must be in a cell array format.');
    end
    if numel(in{1}) ~= numel(in{2})
        error('ERROR! All three input cells need to have the same number of elements.');
    elseif numel(in{2}) ~= numel(in{3})
        error('ERROR! Inputs and number of repetition cells need to have the same number of elements.');
    elseif numel(in{3}) ~= numel(in{4})
        error('ERROR! All 4 input cells need to have the same number of elements.');
    end
    for i = 1:numel(in{3})
        if numel(in{3}{i}) ~= numel(in{4}{i})
            error('ERROR! The number of inputs and number of repetiion elements corresponding to a gait struct should be equal.');
        end
    end
    
    % Unpack
    subgaitFam = in{1};      % subgait 'struct's generated by qlevel2noslip_mp.m
    gaitFam = in{2};         % gait 'struct's generated by qlevel2noslip_mp.m
    inputs = in{3};          % input that picks out a specific gait
    reps = in{4};            % number of repetitions for each input picked

    % initialize
    traj = [];

    % start computing the net trajectory
    for i = 1:numel(gaitFam)

        % current subgaits for the ith and jth contact states
        data_i = subgaitFam{i}{1}; data_j = subgaitFam{i}{2};
        
        % current gaits struct
        data_ij = gaitFam{i};

        if i == 1

            % Extract the body parameters (CONST for all gaits)
            a = data_i{3}.aa; l = data_i{3}.ll; 
            bl = 4*l; % the body length is 4x the link length

            % Extract plotting information--
                                % LineWidths, sizes of SE(2) frames, and Scatter sizes
            lW = data_i{1}.lW; lW_s = data_i{1}.lW_s; lW_r = data_i{1}.lW_r;
            lW_b = data_i{1}.lW_b; lW_qf = data_i{1}.lW_qf; lW_kq = data_i{1}.lW_kq;
            frame_scale = data_i{1}.frame_scale; circS = data_i{1}.circS;

            % pack this into a plotting structure
            plot_info = [];
            plot_info.a = a; plot_info.l = l; plot_info.bl = bl;
            plot_info.lW = lW; 
            plot_info.lW_s = lW_s; plot_info.lW_r = lW_r; plot_info.lW_b = lW_b; 
            plot_info.lW_qf = lW_qf; plot_info.lW_kq = lW_kq;
            plot_info.frame_scale = frame_scale; plot_info.circS = circS;

        end

        % current gait submanifold and color information
        cs_idx_i = data_i{3}.cs_idx; cs_idx_j = data_j{3}.cs_idx;
        cs_i = data_i{3}.cs; cs_j = data_j{3}.cs;
        col = data_i{1}.col;
        c_i = gaitFam{i}.path_i.path_active_color; c_j = gaitFam{i}.path_j.path_active_color;
        gc_col_i = data_i{1}.gc_col; gc_col_j = data_j{1}.gc_col;

        % computing the rearrangement order
        [~, a_ord] = sort([cs_i(:)', cs_j(:)']);

        for j = 1:numel(inputs{i})
            
            % find the current gait information
            iX = find(data_ij.u_i == inputs{i}{j}(1)); iY = find(data_ij.u_j == inputs{i}{j}(2));

            % unpack the shape trajectory
            temp_a1_i    = data_ij.gaits{iX, iY}.trajectory{5} ;
            temp_a2_i    = data_ij.gaits{iX, iY}.trajectory{6} ;
            temp_a1_j    = data_ij.gaits{iX, iY}.trajectory{7} ;
            temp_a2_j    = data_ij.gaits{iX, iY}.trajectory{8} ;
            temp_pbq     = data_ij.gaits{iX, iY}.trajectory{9} ;
            temp_phi_tau = data_ij.gaits{iX, iY}.trajectory{14};

            % extend the shape trajectory
            temp_a1_i    = repmat(temp_a1_i,    1, reps{i}{j});
            temp_a2_i    = repmat(temp_a2_i,    1, reps{i}{j});
            temp_a1_j    = repmat(temp_a1_j,    1, reps{i}{j});
            temp_a2_j    = repmat(temp_a2_j,    1, reps{i}{j});
            temp_pbq     = repmat(temp_pbq,     1, reps{i}{j});
            temp_phi_tau = repmat(temp_phi_tau, 1, reps{i}{j});

            % unpack the SE(2) trajectory
            temp_t       = data_ij.gaits{iX, iY}.trajectory{1} ;
            temp_x       = data_ij.gaits{iX, iY}.trajectory{2} ;
            temp_y       = data_ij.gaits{iX, iY}.trajectory{3} ;
            temp_theta   = data_ij.gaits{iX, iY}.trajectory{4} ;
            temp_zx      = data_ij.gaits{iX, iY}.trajectory{15};
            temp_zy      = data_ij.gaits{iX, iY}.trajectory{16};
            temp_ztheta  = data_ij.gaits{iX, iY}.trajectory{17};
            temp_tf      = sum(data_ij.gaits{iX, iY}.periods.phi_tau);

            % check how many gait cycle repetitions are needed and extend the SE(2) trajectory
            if reps{i}{j} > 1
                
                % initialize
                t_temp = temp_t;
                z_1gc = [temp_zx; temp_zy; temp_ztheta]; ztemp = z_1gc;
                b = [temp_x; temp_y; temp_theta]; temp = b;
                
                % iterate a extend for each repetition
                for k = 2:reps{i}{j}
                    % compute next
                    xyztemp = ztemp + rot_SE2(ztemp(3))*temp;   % update trajectory
                    ztemp = ztemp + rot_SE2(ztemp(3))*z_1gc;  % update net displacement
                    t_temp = temp_tf+t_temp;
                    % update current
                    temp_t = [temp_t, t_temp];
                    b = [b, xyztemp];
                end
                temp_x = b(1, :); temp_y = b(2, :); temp_theta = b(3, :); % update trajectory
                temp_zx = ztemp(1); temp_zy = ztemp(2); temp_ztheta = ztemp(3);
                temp_tf = temp_tf*reps{i}{j};

            end

            % Create the leg colors and reorder both leg trajectory and colors
            temp_alpha = [temp_a1_i; temp_a2_i; temp_a1_j; temp_a2_j];

            temp_b_col = repmat(col(7, :)', 1, size(temp_alpha, 2)); % color for the robot body

            temp_c_col = nan(3, size(temp_alpha, 2)); % color for the k-line between active feet
            temp_c_col(:, temp_phi_tau == cs_idx_i) = repmat(c_i(:), 1, sum(temp_phi_tau == cs_idx_i));
            temp_c_col(:, temp_phi_tau == cs_idx_j) = repmat(c_j(:), 1, sum(temp_phi_tau == cs_idx_j));

            temp_ai_col = temp_b_col; % color for ith contact state
            temp_ai_col(:, temp_phi_tau == cs_idx_i) = repmat(gc_col_i(:), 1, sum(temp_phi_tau == cs_idx_i));
            temp_aj_col = temp_b_col; % color for jth contact state
            temp_aj_col(:, temp_phi_tau == cs_idx_j) = repmat(gc_col_j(:), 1, sum(temp_phi_tau == cs_idx_j)); 
            temp_a_col = {temp_ai_col; temp_ai_col; temp_aj_col; temp_aj_col};

            temp_alpha = temp_alpha(a_ord, :); % reordered shape trajectory with 1->4
            temp_a_col = temp_a_col(a_ord); % reordered the colors
            temp_a_col = cell2mat(temp_a_col);

            temp_t_col = temp_b_col; % trajectory color
            temp_t_col(:, temp_phi_tau == cs_idx_i) = repmat(gc_col_i(:), 1, sum(temp_phi_tau == cs_idx_i));
            temp_t_col(:, temp_phi_tau == cs_idx_j) = repmat(gc_col_j(:), 1, sum(temp_phi_tau == cs_idx_j));

            temp_col_t = [temp_a_col; 
                temp_b_col; 
                temp_c_col; 
                temp_t_col];                                       % color trajectory-- {1}       -- 12xt leg color trajectory
                                                                                      % {2}       -- 3xt robot body color trajectory
                                                                                      % {3}       -- 3xt interleg color for the current contact state
                                                                                      % {4}       -- 3xt current cs color on the SE(2) trajectory
            
            % update the configuration trajectory
            switch i == 1 && j == 1
                
                case 1 % first stitch
                    
                    % just assign since this is the first stitch
                    t       = temp_t;
                    tf      = temp_tf;
                    g       = [temp_x; temp_y; temp_theta];
                    z       = [temp_zx; temp_zy; temp_ztheta];
                    alpha   = temp_alpha;
                    col_t   = temp_col_t;
                    pbq     = [1 zeros(1, numel(temp_pbq)-2) 1]; % just set the last entry as 1 to have the config plotted after every input cycle (1 @ begin to plot IC)
                    phi_tau = temp_phi_tau;
                    dnum    = numel(t);
                    gcVec   = reps{i}{j};

                case 0 % NOT first stitch

                    t       = [t, tf + temp_t];
                    tf      = tf + temp_tf;
                    g       = [   g, z + rot_SE2(z(3))*[temp_x; temp_y; temp_theta]   ];
                    z       = z + rot_SE2(z(3))*[temp_zx; temp_zy; temp_ztheta];
                    alpha   = [ alpha, temp_alpha ];
                    col_t   = [col_t, temp_col_t];
                    pbq     = [pbq, [zeros(1, numel(temp_pbq)-1) 1]];
                    phi_tau = [phi_tau, temp_phi_tau];
                    dnum    = dnum + numel(temp_t);
                    gcVec   = [gcVec, reps{i}{j}];

            end

        end
    end

    % condition the color trajectory correctly
    col_t       = mat2cell(  col_t, 3*ones(1, 7), dnum  ); % color trajectory-- 7x1 cell array (first 4 shape trajectory colors)

    % condition the vector trajectories into cell arrays for each component
    alpha       = mat2cell(  alpha, ones(1, 4), dnum  );
    g           = mat2cell(  g, ones(1, 3), dnum  );


    % Pack the trajectory and return it
    traj.dnum       = dnum;
    traj.gcVec      = gcVec;
    traj.t          = t;
    traj.tf         = tf;
    traj.g          = g;
    traj.z          = z;
    traj.alpha      = alpha;
    traj.col_t      = col_t;
    traj.pbq        = pbq;
    traj.phi_tau    = phi_tau;

    % compute the plotting trajectory
    pltTraj = compute_pltTraj(    data_i{4},   {g, alpha, col_t, phi_tau, pbq, dnum},   {a, l, bl}   );  % get the trajectories
    pltTraj.plot_info = plot_info; % append plotting fields

end

