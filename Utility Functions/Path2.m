% This is a "Path2" class for defining paths on level-2 no-slip contact
% submanifolds for a rigid quadrupedal robot. It takes the initial 
% condition for the shape-space slice (2 dim), gait constraint vector field
% (2 dim), and integration time for the path to construct a Path2 object. 
% It inherits properties from the abstract class "RigidGeomQuad".

classdef Path2 < RigidGeomQuad

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    properties (SetAccess = private)

        active_state         % the contact state that this path belongs to; an integer in the range (1, 6)
                             % the contact state ordering is as follows {12, 23, 34, 41, 13, 24}

        dz                   % Gait constraint based stratified panel dzij-- [A]*\Vec{d\phi}_{ij}

        dphi                 % Gait constraint vector field dphi_ij-- \Vec{dphi}_{ij}

        ddphi                % Shape(directional)-derivative of the gait constraint vector field-- \Nabla_\alpha \Vec{dphi}_{ij}

        A                    % Local connection vector field-- \boldsymbol{A}_{ij}

        Adot                 % Shape(directional)-derivative of the local connection vector field-- \Nabla_\alpha \boldsymbol{A}_{ij}

        point_of_interest    % starting point to compute the path

        int_dirn             % direction to integrate the path along: +phi or -phi with scaling

        int_time             % Integration time in the backward (1) and forward direction (2) from the middle_path

        int_cond             % checks if the pof is on the path, beginning, or at the end of the path

        deadband_dutycycle   % period of time spent swinging in the sub-gait (0 <= val <= 1)
                             % path psi in submanifold + path to return to starting point through the nullspace of the submanifold

        scale_path_method    % method to scale the path about the "point_of_interest"-- this prop then scales the time vector for the closed length path
                             % and changes the ordering based on final time. Some examples include, 'accln', 'vel'

        initial_condition    % this is the starting point of the path

        final_condition      % this is the ending point of the path

        open_trajectory      % configuration trajectory for the active path

        net_displacement     % the net displacement generated by open/closed trajectories

        path_curvature_traj  % the curvature of the path (\kappa) (1/ radius of curvature) trajectory

        path_net_curvature   % the net curvature of the path (\kappa) (1/ radius of curvature)

        closed_trajectory    % configuration trajectory for the whole subgait (both forward and backward paths)

        open_trajectory_vel  % configuration velocity from the forward path

        closed_trajectory_vel% configuration velocity from the whole subgait

        open_trajectory_acc  % configuration acceleration from the forward path

        closed_trajectory_acc% configuration acceleration from the whole subgait

        path_length          % length of the path

        path_active_color    % color of the trajectory based on the gait constraint color map

        path_inactive_color  % color of the trajectory during the deadband

        path_discretization  % number of points in the active contact state

    end

    methods
        
        % Constructor
        function [thisPath2] = Path2( ank, a, l, dzij, dphiij, ddphiij, Aij, Adotij, strpt, t, dc, c, si, dirn )

            % Setup the requirements for the arguments
            arguments
                
                ank     (1, 1) double {mustBeGreaterThan(ank,0.1)}

                a       (1, 1) double {mustBeGreaterThan(a,0.1)}

                l       (1, 1) double {mustBeGreaterThan(l,0.1)}

                dzij    (3, 1) sym    {mustBeA(dzij, 'sym')}

                dphiij  (2, 1) sym    {mustBeA(dphiij, 'sym')}

                ddphiij (2, 2) sym    {mustBeA(ddphiij, 'sym')}

                Aij     (3, 2) sym    {mustBeA(Aij, 'sym')}

                Adotij  (1, 2) cell   {mustBeA(Adotij, 'cell')} % each cell contains a (3,2) symbolic array

                strpt   (1, 2) double {mustBeNumeric}

                t       (1, 2) double {mustBeNonnegative}

                dc      (1, 1) double {mustBeNonnegative, mustBeLessThanOrEqual(dc, 1)}

                c       (2, 3) double {mustBeLessThanOrEqual(c, 1)}

                si      (1, 1) double {mustBePositive, mustBeLessThanOrEqual(si, 6)}

                dirn    (1, 1) double {mustBeLessThanOrEqual(dirn, 1), mustBeGreaterThanOrEqual(dirn, -1)}

            end

            % Get the arguments for a superclass constuctor
            if nargin == 14
                quadArgs = [ank, a, l];
            elseif nargin == 12
                quadArgs = ank;
            elseif nargin == 11
                quadArgs = [];
            else
                error('Error: Need 14, 12, or 11 arguments to create an object.');
            end

            % call the RigidGeometricQuadruped class' constructor
            thisPath2 = thisPath2@RigidGeomQuad(quadArgs);

            % assign the props
            thisPath2.dz = dzij;
            thisPath2.dphi = dphiij;
            thisPath2.ddphi = ddphiij;
            thisPath2.A = Aij;
            thisPath2.Adot = Adotij;
            thisPath2.point_of_interest = strpt;
            thisPath2.int_time = t;
            thisPath2.deadband_dutycycle = dc;
            thisPath2.path_active_color = c(1,:);
            thisPath2.path_inactive_color = c(2,:);
            thisPath2.active_state = si;
            thisPath2.int_dirn = dirn;

            % increment the number of objects
            Path2.SetGet_static(1);

        end
        
        
    end

    methods (Static)
        
        % static function to icnrement the number of objects
        function out = SetGet_static(~)
            
            persistent var

            if isempty(var)
                var = 0;
            end

            if nargin == 1

                var = var + 1;

            else

                out = var;

            end

        end

        % Compute the open_trajectory
        function compute_trajectory( thePath2, funcstr, dnum )
        
            % initialize the return container-- we shall return percentages (from -100% to 100% in steps of 10%) of the generated full open_trajectory
            num_scale = 20;
            thePath2.open_trajectory = cell(1,num_scale);
            thePath2.path_length = cell(1,num_scale);
            
            % RigidGeometricQuadruped 's inherited props
            aa = thePath2.get_a; 
            ll = thePath2.get_l;
            
            % check if we want the integration condition
            if numel(thePath2.int_time(thePath2.int_time == 0)) ~= 2                 % make sure some path is needed
                if isempty(thePath2.int_time(thePath2.int_time == 0))                % if both paths are needed
                    cond = 0;                                           
                elseif find(thePath2.int_time == 0) == 1                             % if only the forward path is needed
                    cond = 1;
                elseif find(thePath2.int_time == 0) == 2                             % if only the backward path is needed
                    cond = -1;
                end
            else                                                                     % error if the integration time for both fwd and backward paths are zero.
                error('ERROR: The intergration time in both directions can''t be zero.');
            end
            thePath2.int_cond = cond; % updated the integration property
            
            % integrate the gait constraint ode to obtain the open-trajectory for the system.
            ai0 = thePath2.point_of_interest(1);  % initial conditions
            aj0 = thePath2.point_of_interest(2);

            % unpack the integration direction
            dirn = thePath2.int_dirn;
            
            % get the functions needed to integrate-- 'symbolic' datatype to 'matlabFunction' format
            eval(funcstr{1}) % initialize the symbolic variables
            DPHI = matlabFunction(dirn*thePath2.dphi, 'Vars', eval(funcstr{2})); % dirn chooses whether it will be positive or negative
            DQ = [cos(theta), -sin(theta),  0, 0, 0;
                  sin(theta), cos(theta),   0, 0, 0;
                  0,          0,            1, 0, 0;
                  0,          0,            0, 1, 0;
                  0,          0,            0, 0, 1]*[thePath2.dz; thePath2.dphi]*dirn;
            DQ = matlabFunction(DQ, 'Vars', eval(funcstr{3}));                   % configuration vector field

            % integrate
            switch cond
            
                case -1 % just backward path
            
                    tt = linspace(0, thePath2.int_time(1), dnum); % backward-- get the start point of path
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] ); % forward to POF
                
                case 0 % both paths
            
                    tt = linspace(0, thePath2.int_time(1), dnum); % backward-- get the start point of path
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    tt = linspace(0, sum(thePath2.int_time), dnum); % forward-- integrate the configuration
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
            
                case 1 % just forward path
                    
                    tt = linspace(0, thePath2.int_time(2), dnum); % just go forward from POF
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); ai0; aj0] );
            
            end

            % Some more functions for identifying the path curvature
            A     =  matlabFunction(thePath2.A, 'Vars', eval(funcstr{2})); % local connection
            ADOTi = matlabFunction(thePath2.Adot{1}, 'Vars', eval(funcstr{2})); % the directional derivatives of the local connection
            ADOTj = matlabFunction(thePath2.Adot{2}, 'Vars', eval(funcstr{2}));
            DDPSI = matlabFunction(dirn*thePath2.ddphi, 'Vars', eval(funcstr{2})); % the directional derivative of the path constraint
            
            % Here, we shall compute/interpolate and store the positive and negatively scaled gaits ------------------------------------------------------------

            % Get the path velocity & store the open configuration trajectory slice q(s)_ij for the full path
            thePath2.open_trajectory{20} = {tf(:)', qf(:,1)', qf(:,2)', qf(:,3)', qf(:,4)', qf(:,5)'}'; % +100% path
            thePath2.open_trajectory{1} = {tf(:)', fliplr((-qf(end,1) + qf(:,1))'), fliplr((-qf(end,2) + qf(:,2))'), fliplr((-qf(end,3) + qf(:,3))'),...
                fliplr(qf(:,4)'), fliplr(qf(:,5)')}'; % -100% path
            % {x, y, \theta, \alpha_i, \alpha_j}
            Qdot20 = DQ(  thePath2.open_trajectory{20}{1}, aa, ll,...
                thePath2.open_trajectory{20}{2}, thePath2.open_trajectory{20}{3}, thePath2.open_trajectory{20}{4},...
                thePath2.open_trajectory{20}{5}, thePath2.open_trajectory{20}{6}  ); % local configuration velocity
            Qdot1 = DQ(  thePath2.open_trajectory{1}{1}, aa, ll,...
                thePath2.open_trajectory{1}{2}, thePath2.open_trajectory{1}{3}, thePath2.open_trajectory{1}{4},...
                thePath2.open_trajectory{1}{5}, thePath2.open_trajectory{1}{6}  );
            % get the path vel, accln, and curvature information
            [thePath2.path_net_curvature{20}, thePath2.path_curvature_traj{20}, ...
                thePath2.open_trajectory_vel{20}, thePath2.open_trajectory_acc{20}] = ...
                extractPathCurvFromQ2(thePath2.open_trajectory{20}, Qdot20, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
            [thePath2.path_net_curvature{1}, thePath2.path_curvature_traj{1}, ...
                thePath2.open_trajectory_vel{1}, thePath2.open_trajectory_acc{1}] = ...
                extractPathCurvFromQ2(thePath2.open_trajectory{1}, Qdot1, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
            % store the initial and final conditions of the path
            thePath2.initial_condition{20} = [thePath2.open_trajectory{20}{5}(1) thePath2.open_trajectory{20}{6}(1)];
            thePath2.final_condition{20} = [thePath2.open_trajectory{20}{5}(end) thePath2.open_trajectory{20}{6}(end)];
            thePath2.initial_condition{1} = [thePath2.open_trajectory{1}{5}(1) thePath2.open_trajectory{1}{6}(1)];
            thePath2.final_condition{1} = [thePath2.open_trajectory{1}{5}(end) thePath2.open_trajectory{1}{6}(end)];
            % compute the net displacement
            thePath2.net_displacement(:,20) = [thePath2.open_trajectory{20}{2}(end), thePath2.open_trajectory{20}{3}(end), thePath2.open_trajectory{20}{4}(end)]';
            thePath2.net_displacement(:,1) = [thePath2.open_trajectory{1}{2}(end), thePath2.open_trajectory{1}{3}(end), thePath2.open_trajectory{1}{4}(end)]';
            % store the closed trajectory
            [thePath2.closed_trajectory{20}, ...
                thePath2.closed_trajectory_vel{20}, thePath2.closed_trajectory_acc{20}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{20},...
                thePath2.open_trajectory_vel{20}, thePath2.open_trajectory_acc{20}, thePath2.deadband_dutycycle);
            [thePath2.closed_trajectory{1}, ...
                thePath2.closed_trajectory_vel{1}, thePath2.closed_trajectory_acc{1}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{1},...
                thePath2.open_trajectory_vel{1}, thePath2.open_trajectory_acc{1}, thePath2.deadband_dutycycle);
            % since the gait-constraint vector field has unit magnitude, the path length is just the final time of the path
            thePath2.path_length{20} = thePath2.open_trajectory{20}{1}(end);
            thePath2.path_length{1} = thePath2.open_trajectory{1}{1}(end);
            
            % compute multiples of 10% paths to add to the "open_trajectory" and "path_length" props
            for i = 1:0.5*num_scale-1
                
                iP = 0.5*num_scale + i;     % indices for positively scaled paths
                iN = 0.5*num_scale - i + 1; % indices for negatively scaled paths
                
                % compute interpolated positively scaled paths
                thePath2.open_trajectory{iP} = thePath2.interpolated_open_trajectory(thePath2.open_trajectory{20}, i*0.1, cond, dnum); % compute the scaled path
                QdotP = DQ(  thePath2.open_trajectory{iP}{1}, aa, ll, 0, 0, 0, thePath2.open_trajectory{iP}{5}, thePath2.open_trajectory{iP}{6}  );
                [thePath2.path_net_curvature{iP}, thePath2.path_curvature_traj{iP},...
                    thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}] = ...
                    extractPathCurvFromQ2(thePath2.open_trajectory{iP}, QdotP, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                thePath2.net_displacement(:,iP) = [thePath2.open_trajectory{iP}{2}(end), thePath2.open_trajectory{iP}{3}(end), thePath2.open_trajectory{iP}{4}(end)]';
                [thePath2.closed_trajectory{iP}, ...
                thePath2.closed_trajectory_vel{iP}, thePath2.closed_trajectory_acc{iP}] = ...
                            thePath2.close_trajectory(thePath2.open_trajectory{iP},...
                            thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}, thePath2.deadband_dutycycle);
                thePath2.path_length{iP} = thePath2.open_trajectory{iP}{1}(end); % get the path length
                thePath2.initial_condition{iP} = [thePath2.open_trajectory{iP}{5}(1) thePath2.open_trajectory{iP}{6}(1)]; % path initial and final conditions
                thePath2.final_condition{iP} = [thePath2.open_trajectory{iP}{5}(end) thePath2.open_trajectory{iP}{6}(end)];
                
                % compute interpolated negatively scaled paths
                thePath2.open_trajectory{iN} = thePath2.interpolated_open_trajectory(thePath2.open_trajectory{1}, i*0.1, cond, dnum);
                QdotN = DQ(  thePath2.open_trajectory{iN}{1}, aa, ll, 0, 0, 0, thePath2.open_trajectory{iN}{5}, thePath2.open_trajectory{iN}{6}  );
                [thePath2.path_net_curvature{iN}, thePath2.path_curvature_traj{iN},...
                    thePath2.open_trajectory_vel{iN}, thePath2.open_trajectory_acc{iN}] = ...
                    extractPathCurvFromQ2(thePath2.open_trajectory{iN}, QdotN, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                thePath2.net_displacement(:,iN) = [thePath2.open_trajectory{iN}{2}(end), thePath2.open_trajectory{iN}{3}(end), thePath2.open_trajectory{iN}{4}(end)]';
                [thePath2.closed_trajectory{iN}, ...
                thePath2.closed_trajectory_vel{iN}, thePath2.closed_trajectory_acc{iN}] = ...
                            thePath2.close_trajectory(thePath2.open_trajectory{iN},...
                            thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}, thePath2.deadband_dutycycle); 
                thePath2.path_length{iN} = thePath2.open_trajectory{iN}{1}(end);
                thePath2.initial_condition{iN} = [thePath2.open_trajectory{iN}{5}(1) thePath2.open_trajectory{iN}{6}(1)];
                thePath2.final_condition{iN} = [thePath2.open_trajectory{iN}{5}(end) thePath2.open_trajectory{iN}{6}(end)];
            end

            % store the path discretization
            thePath2.path_discretization = dnum;
        
        end

        % Compute the open_trajectory-- sliding kind
        function compute_slide_trajectory( thePath2, funcstr, dnum, mul )
        
            % initialize the return container-- we shall return percentages of the slide from 100% to -100%
            num_scale = 21; % the middle gait is first computed and it is slid on both sides
            thePath2.open_trajectory = cell(1,num_scale);
            thePath2.path_length = cell(1,num_scale);
            
            aa = thePath2.get_a; 
            ll = thePath2.get_l;
            
            if numel(thePath2.int_time(thePath2.int_time == 0)) ~= 2
                if isempty(thePath2.int_time(thePath2.int_time == 0))
                    cond = 0;                                           
                elseif find(thePath2.int_time == 0) == 1
                    cond = 1;
                elseif find(thePath2.int_time == 0) == 2
                    cond = -1;
                end
            else
                error('ERROR: The intergration time in both directions can''t be zero.');
            end
            thePath2.int_cond = cond;
            
            ai0 = thePath2.point_of_interest(1);
            aj0 = thePath2.point_of_interest(2);
            
            dirn = thePath2.int_dirn;
            
            eval(funcstr{1})
            DPHI = matlabFunction(dirn*thePath2.dphi, 'Vars', eval(funcstr{2}));
            DQ = [cos(theta), -sin(theta),  0, 0, 0;
                  sin(theta), cos(theta),   0, 0, 0;
                  0,          0,            1, 0, 0;
                  0,          0,            0, 1, 0;
                  0,          0,            0, 0, 1]*[thePath2.dz; thePath2.dphi]*dirn;
            DQ = matlabFunction(DQ, 'Vars', eval(funcstr{3}));
            
            switch cond
            
                case -1
            
                    tt = linspace(0, mul(1)*thePath2.int_time(1), dnum);
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
                
                case 0
            
                    tt = linspace(0, mul(1)*thePath2.int_time(1), dnum);
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    tt = linspace(0, sum(mul.*thePath2.int_time), dnum);
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
            
                case 1
                    
                    tt = linspace(0, mul(2)*thePath2.int_time(2), dnum);
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); ai0; aj0] );
            
            end
            
            A     =  matlabFunction(thePath2.A, 'Vars', eval(funcstr{2}));
            ADOTi = matlabFunction(thePath2.Adot{1}, 'Vars', eval(funcstr{2}));
            ADOTj = matlabFunction(thePath2.Adot{2}, 'Vars', eval(funcstr{2}));
            DDPSI = matlabFunction(dirn*thePath2.ddphi, 'Vars', eval(funcstr{2}));

            Qfull = {tf(:)', qf(:,1)', qf(:,2)', qf(:,3)', qf(:,4)', qf(:,5)'}'; % the configuration path over the full slide range!!
            Qdotfull = DQ(  Qfull{1}, aa, ll,...
                Qfull{2}, Qfull{3}, Qfull{4},...
                Qfull{5}, Qfull{6}  );
            idxNom = ceil(num_scale/2); t0 = (mul(1) - 1)*thePath2.int_time(1); tPi = t0 + sum(thePath2.int_time); tNom = linspace(t0, tPi, dnum);
            thePath2.open_trajectory{idxNom} = configInterp(tNom, Qfull); % +0% slid path (nominal)
            [thePath2.path_net_curvature{idxNom}, thePath2.path_curvature_traj{idxNom}, ...
                thePath2.open_trajectory_vel{idxNom}, thePath2.open_trajectory_acc{idxNom}] = ...
                extractPathCurvFromQ2(Qfull, Qdotfull, DDPSI, A, {ADOTi, ADOTj}, {aa, ll}); % curvature, vel, and accln for the path above
            thePath2.initial_condition{idxNom} = [thePath2.open_trajectory{idxNom}{5}(1) thePath2.open_trajectory{idxNom}{6}(1)];
            thePath2.final_condition{idxNom} = [thePath2.open_trajectory{idxNom}{5}(end) thePath2.open_trajectory{idxNom}{6}(end)];
            thePath2.net_displacement(:,idxNom) = [thePath2.open_trajectory{idxNom}{2}(end), thePath2.open_trajectory{idxNom}{3}(end), thePath2.open_trajectory{idxNom}{4}(end)]';
            [thePath2.closed_trajectory{idxNom}, ...
                thePath2.closed_trajectory_vel{idxNom}, thePath2.closed_trajectory_acc{idxNom}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{idxNom},...
                thePath2.open_trajectory_vel{idxNom}, thePath2.open_trajectory_acc{idxNom}, thePath2.deadband_dutycycle);
            thePath2.path_length{idxNom} = thePath2.open_trajectory{idxNom}{1}(end);
            slide_perct = linspace(-1, 1, num_scale);
            for i = [1:idxNom-1, idxNom+1:num_scale]
                    t0Now = (1- slide_perct(i))*(mul(1) - 1)*thePath2.int_time(1); tPiNow = t0Now + sum(thePath2.int_time); tNow = linspace(t0Now, tPiNow, dnum);
                    thePath2.open_trajectory{i} = configInterp(tNow, Qfull);
                    QdotNow = DQ(  thePath2.open_trajectory{i}{1}, aa, ll,...
                        thePath2.open_trajectory{i}{2}, thePath2.open_trajectory{i}{3}, thePath2.open_trajectory{i}{4},...
                        thePath2.open_trajectory{i}{5}, thePath2.open_trajectory{i}{6}  );
                    [thePath2.path_net_curvature{i}, thePath2.path_curvature_traj{i}, ...
                        thePath2.open_trajectory_vel{i}, thePath2.open_trajectory_acc{i}] = ...
                        extractPathCurvFromQ2(thePath2.open_trajectory{i}, QdotNow, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                    thePath2.initial_condition{i} = [thePath2.open_trajectory{i}{5}(1) thePath2.open_trajectory{i}{6}(1)];
                    thePath2.final_condition{i} = [thePath2.open_trajectory{i}{5}(end) thePath2.open_trajectory{i}{6}(end)];
                    thePath2.net_displacement(:,i) = [thePath2.open_trajectory{i}{2}(end), thePath2.open_trajectory{i}{3}(end), thePath2.open_trajectory{i}{4}(end)]';
                    [thePath2.closed_trajectory{i}, ...
                        thePath2.closed_trajectory_vel{i}, thePath2.closed_trajectory_acc{i}] = ...
                        thePath2.close_trajectory(thePath2.open_trajectory{i},...
                thePath2.open_trajectory_vel{i}, thePath2.open_trajectory_acc{i}, thePath2.deadband_dutycycle);
                    thePath2.path_length{i} = thePath2.open_trajectory{i}{1}(end);
            end
            thePath2.path_discretization = dnum;
        
        end
        
        % This function computes different percentages of the open-trajectory by keeping "path_start" prop constant, and using interp1 with the spline method.
        function q_interp = interpolated_open_trajectory(fullPath2, p, cond, dnum)
            
            % unpack your open_trajectory
            t = fullPath2{1};
            x = fullPath2{2};
            y = fullPath2{3};
            theta = fullPath2{4};
            ai = fullPath2{5};
            aj = fullPath2{6};

            % get the limitng points
            switch cond

                case -1
                    
                    leftpt = numel(t) - floor(p*numel(t)); rightpt = numel(t);

                case  0

                    midpt = ceil(numel(t)/2);
                    leftpt = midpt - p*(midpt-1); rightpt = midpt + p*(midpt-1);

                case  1

                    leftpt = 1; rightpt = ceil(p*numel(t));
                    
            end

            % get the modified trajectory
            t_temp = t(leftpt:rightpt); t_temp = t_temp - t_temp(1);
            x_temp = x(leftpt:rightpt); x_temp = x_temp - x_temp(1);
            y_temp = y(leftpt:rightpt); y_temp = y_temp - y_temp(1);
            theta_temp = theta(leftpt:rightpt); theta_temp = theta_temp - theta_temp(1);
            ai_temp = ai(leftpt:rightpt);
            aj_temp = aj(leftpt:rightpt);

            % interpolate to a desired discretization
            T = linspace(t_temp(1), t_temp(end), dnum);
            X = interp1(t_temp, x_temp, T, 'pchip');
            Y = interp1(t_temp, y_temp, T, 'pchip');
            THETA = interp1(t_temp, theta_temp, T, 'pchip');
            AI = interp1(t_temp, ai_temp, T, 'pchip');
            AJ = interp1(t_temp, aj_temp, T, 'pchip');

            % return the solution
            q_interp = {T(:)', X(:)', Y(:)', THETA(:)', AI(:)', AJ(:)'}';

        end

        % given a trajectory close it in the null-space of the shape-space slice
        function [gaitTraj, gaitTraj_vel, gaitTraj_acc] = close_trajectory(openTraj, openTraj_vel, openTraj_acc, dc)
            
            % unpack your open_trajectory
            t       = openTraj{1};        t_dot         = openTraj_vel{1};        t_ddot         = openTraj_acc{1};
            x       = openTraj{2};        x_dot         = openTraj_vel{2};        x_ddot         = openTraj_acc{2};
            y       = openTraj{3};        y_dot         = openTraj_vel{3};        y_ddot         = openTraj_acc{3};
            theta   = openTraj{4};        theta_dot     = openTraj_vel{4};        theta_ddot     = openTraj_acc{4};
            ai      = openTraj{5};        ai_dot        = openTraj_vel{5};        ai_ddot        = openTraj_acc{5};
            aj      = openTraj{6};        aj_dot        = openTraj_vel{6};        aj_ddot        = openTraj_acc{6};

            % get the length of the computed open trajectory
            dnum_active = numel(t);
            
            % get the number of points needed in the deadband
            dnum_dead = round(dc*dnum_active);

            % get the deadband configuration trajectories q_d
            t_d = [t, t(end) + t(end)/(dnum_active - 1)*(1:dnum_dead)]; t_dot_d = ones(1, dnum_dead); t_ddot_d = zeros(1, dnum_dead);
            x_d = [x, x(end)*ones(1, dnum_dead)]; x_dot_d = [x_dot, zeros(1, dnum_dead)]; x_ddot_d = [x_ddot, zeros(1, dnum_dead)]; 
            y_d = [y, y(end)*ones(1, dnum_dead)]; y_dot_d = [y_dot, zeros(1, dnum_dead)]; y_ddot_d = [y_ddot, zeros(1, dnum_dead)];
            theta_d = [theta, theta(end)*ones(1, dnum_dead)]; theta_dot_d = [theta_dot, zeros(1, dnum_dead)]; theta_ddot_d = [theta_ddot, zeros(1, dnum_dead)];
            ai_d = [ai, fliplr(ai(2:end-1))]; ai_dot_d = [ai_dot, fliplr(ai_dot(2:end-1))]; ai_ddot_d = [ai_ddot, fliplr(ai_ddot(2:end-1))];
            aj_d = [aj, fliplr(aj(2:end-1))]; aj_dot_d = [aj_dot, fliplr(aj_dot(2:end-1))]; aj_ddot_d = [aj_ddot, fliplr(aj_ddot(2:end-1))];      

            % create the closed configuration trajectories
            gaitTraj    = {     t_d;       x_d;      y_d;      theta_d;      ai_d;      aj_d};
            gaitTraj_vel= { t_dot_d;   x_dot_d;  y_dot_d;  theta_dot_d;  ai_dot_d;  aj_dot_d};
            gaitTraj_acc= {t_ddot_d;  x_ddot_d; y_ddot_d; theta_ddot_d; ai_ddot_d; aj_ddot_d};

        end
        
        % This function computes the no-slip shape var 2 trajectory given shape var 1 traj.
        function [rout, rout_dot] = compute_noslip_trajectory(in)
            
            % Unpack
            rinp = in{1}; % pure sine params
            t = in{2}; % time vector
            dpsi = in{3}; % 2x1 vector output
            rin0 = in{4}; % ic
            aa = in{5}; ll = in{6}; % robot params
            
            % Compute requirements to compute 'rout_dot'
            rin = genswing_t(t, rinp); rin_dot = genswingrate_t(t, rinp);

            % ODE intergrate to obtain 'rout'
            [~, rout] = ode45(   @(t,x) (  [0, 1]*dpsi( aa, ll, genswing_t(t, rinp), x )  ) ./...
                (  [1, 0]*dpsi( aa, ll, genswing_t(t, rinp), x) ) .* genswingrate_t(t, rinp),...
                t - t(1), rin0   ); % compute
            rout = rout(:)'; % row vector needed

            % vectorially compute 'rout_dot'
            rout_dot = (  [0, 1]*dpsi( aa, ll, rin, rout )  ) ./ (  [1, 0]*dpsi( aa, ll, rin, rout) ) .* rin_dot;

        end

        % given a contact and shape trajectory-- say from an experiment, obtain an estimate for the SE(2) body velocity and then integrate it to obtain the body
        % trajectory
        % % case 0: shape trajectories estimated from experiments
        % % case 1: pure sinusoidal swing with contact during backward swing
        % % case 2: case 1 but with phase offset to reduce slip between 
        function b_hat = estimate_SE2_trajectory(in, robot_params)

            % Unpack
            pfaff_i = robot_params{1}; aa = robot_params{2}; ll = robot_params{3};
            bic = in{1}; t = in{2}; that = t - t(1);

            switch numel(in{3})
                case 2
                    if numel(in{3}{1}) ~= numel(in{3}{2})
                        error('ERROR! The length of r and r_dot must be equal.');
                    end
                    verifylength(in{3}{1});
                    verifylength(in{3}{2});
                    for idx = 1:numel(in{3}{1})
                        if numel(in{3}{1}{idx}) ~= numel(t)
                            error(['ERROR! The length of trajectory element r_'...
                                num2str(idx) ' and t must be equal.']);
                        end
                        if numel(in{3}{2}{idx}) ~= numel(t)
                            error(['ERROR! The length of trajectory element r_dot_'...
                                num2str(idx) ' and t must be equal.']);
                        end
                    end
                    r = in{3}{1}; r_dot = in{3}{2};
                case 1
                    % if it is not a pure sine fit, then return an error
                    % fit form: mul*yamp*cos(2*pi*f*(t - tau)) + y_dc
                    % params order: {mul, yamp, f, tau, y_dc}
                    for idx = 1:numel(in{3}{1})
                        if numel(in{3}{1}{idx}) ~= 5
                            error(['ERROR! This function only accepts time-series arrays {1x2}{8x1}[1xtn] or' ...
                                ' pure sine fits {1x1}{8x1}[5x1].']);
                        end
                    end
                    [r, r_dot] = genSine_r_rdot(in{3}{1}, t);
            end
            if numel(r) == 8
                r = r(1:2:end); r_dot = r_dot(1:2:end);
            end

            switch size(in{4}{1}, 1)
                case 1
                    c = in{4};
                case 3
                    if numel(robot_params) ~= 4
                        error(['ERROR! For recreating contact trajectory from leg_z trajectory, a threshold' ...
                            'value is needed as the 4th input in the second argument.'])
                    end
                    c = expkin_contact_thresholding(in{4} ,robot_params{4});
            end
            r = convert2case1convention(r); r_dot = convert2case1convention(r_dot); % conversion to case 1 format

            % Initial condition for body trajectory
            x0 = [-bic{2}; bic{1}; bic{3}];

             % Compute the body velocity using ode45
            warning("off"); % switch off interpolation warnings and switch it back on after integrating the ode
            [~, b_hat_temp] = ode45(  @(t,x) compute_SE2bodyvelocityfromfullJ( t, aa, ll, x, {c, pfaff_i, r, r_dot, that}), that, x0  ); % pass the time vector for interp1
            warning("on");
            b_hat{1} = b_hat_temp(:, 2); b_hat{2} = -b_hat_temp(:, 1); b_hat{3} = b_hat_temp(:, 3); % convert it back to the HAMR Kinematics format
            b_hat{1} = b_hat{1}(:)'; b_hat{2} = b_hat{2}(:)'; b_hat{3} = b_hat{3}(:)'; b_hat = b_hat(:); % make them row time-series and stack the cell array
            
        end
        
        
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
end